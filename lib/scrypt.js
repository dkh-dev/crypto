'use strict'

const crypto = require('crypto')

const hmac = require('./hmac')
const randomBytes = require('./random-bytes')
const { callback } = require('./utils/promisify')


const SCRYPT_OPTIONS = {
  N: 16384,
  r: 8,
  p: 1,
}

/**
 * @private
 */
const scryptAsync = callback(crypto.scrypt)

/**
 * Derives `maxmem` from the current options.
 * @private
 */
const scryptOptions = ({ N, r, p }) => ({ N, r, p, maxmem: 256 * N * r })

/**
 * Note: You might want to use `scrypt.hash()` instead.
 */
const scrypt = (password, salt, keylen, options = SCRYPT_OPTIONS) => {
  const {
    N = SCRYPT_OPTIONS.N,
    r = SCRYPT_OPTIONS.r,
    p = SCRYPT_OPTIONS.p,
  } = options

  return scryptAsync(password, salt, keylen, scryptOptions({ N, r, p }))
}


/**
 * @private
 */
const hashiv = async (password, iv, data) => {
  const N = 2 ** iv.readUInt8(0)
  const r = iv.readUInt8(1)
  const p = iv.readUInt8(2)

  const key = await scrypt(password, iv, 32, scryptOptions({ N, r, p }))

  return Buffer.concat([ iv, await hmac.sha256(key, data) ])
}

/**
 * Hash data using `scrypt`.
 * @see verify
 * @param {(string|Buffer|TypedArray|DataView)} password
 * @param {(string|Buffer|TypedArray|DataView)} data
 * @param {number} [options]
 * @param {number} [options.N] 1 ≲ log2(N) ≲ 255
 * @param {number} [options.r] 1 ≲ r ≲ 255
 * @param {number} [options.p] 1 ≲ p ≲ 255
 */
const hash = async (password, data, options = SCRYPT_OPTIONS) => {
  const {
    N = SCRYPT_OPTIONS.N,
    r = SCRYPT_OPTIONS.r,
    p = SCRYPT_OPTIONS.p,
  } = options

  const iv = Buffer.alloc(35)
  const salt = await randomBytes(32)

  iv.writeUInt8(Math.log2(N))
  iv.writeUInt8(r, 1)
  iv.writeUInt8(p, 2)

  salt.copy(iv, 3)

  return hashiv(password, iv, data)
}

/**
 * Verifies a `scrypt` hash which is generated by `scrypt.hash()`.
 * @see hash
 * @param {(string|Buffer|TypedArray|DataView)} password
 * @param {(string|Buffer|TypedArray|DataView)} data
 * @param {(string|Buffer|TypedArray|DataView)} hash
 */
const verify = async (password, data, hash) => {
  const buffer = Buffer.from(hash)
  const iv = buffer.slice(0, 35)

  return crypto.timingSafeEqual(buffer, await hashiv(password, iv, data))
}

module.exports = {
  SCRYPT_OPTIONS,
  hash,
  verify,
  scrypt,
}
