'use strict'

const { timingSafeEqual } = require('crypto')

const { sha256 } = require('./hmac')
const { randomBytes, scrypt } = require('./crypto')
const { split, read, from } = require('./utils/bytes')


const SCRYPT_KEY_SIZE = 32
const SCRYPT_DEFAULT_OPTIONS = {
  N: 16384,
  r: 8,
  p: 1,
}
const SCRYPT_DEFAULT_IV_SIZE = {
  logN: 1,
  r: 1,
  p: 1,
}
const SCRYPT_DEFAULT_SALT_SIZE = 32


/**
 * log2(N), r, p must be of size `SCRYPT_DEFAULT_IV_SIZE`.
 *
 * Storing sizes of log2(N), r, p in the `iv` allows backwards-compatible
 *   verifications against a scrypt hash.
 */
const deriveIv = (
  options = SCRYPT_DEFAULT_OPTIONS,
  size = SCRYPT_DEFAULT_IV_SIZE,
) => {
  const { N, r, p } = options
  const parameters = [
    Math.log2(N),
    r,
    p,
  ]
  const sizes = [
    size.logN,
    size.r,
    size.p,
  ]

  const iv = from(sizes, parameters)

  const metadata = Uint8Array.from(sizes)

  return Buffer.concat([ metadata, iv ])
}

/**
 * Derives scrypt options from `iv`.
 */
const deriveOptions = iv => {
  const sizes = read(iv, [ 1, 1, 1 ])
  const [ logN, r, p ] = read(iv, sizes, 3)

  return {
    r,
    p,
    N: 2 ** logN,
  }
}

/**
 * This is `crypto.scrypt`
 * Note: You might want to use `scrypt.hash()` instead.
 */
const derive = (password, salt, keylen, options = SCRYPT_DEFAULT_OPTIONS) => {
  const {
    N = SCRYPT_DEFAULT_OPTIONS.N,
    r = SCRYPT_DEFAULT_OPTIONS.r,
    p = SCRYPT_DEFAULT_OPTIONS.p,
  } = options
  const maxmem = (128 * p * r) + (32 * (2 + N) * r * 4)

  return scrypt(password, salt, keylen, { N, r, p, maxmem })
}

/**
 * Hash data using `scrypt` and `sha256`.
 *
 * Note: You might want to use `scrypt.hash()` instead.
 */
const hashiv = async (password, iv, salt, data) => {
  const key = await derive(password, salt, SCRYPT_KEY_SIZE, deriveOptions(iv))
  const hmac = await sha256(key, data)

  const metadata = Uint8Array.from([ iv.length, salt.length ])

  return Buffer.concat([
    metadata,
    iv,
    salt,
    hmac,
  ])
}


/**
 * Hash data using `scrypt`.
 * @see verify
 * @param {(string|Buffer|TypedArray|DataView)} password
 * @param {(string|Buffer|TypedArray|DataView)} data
 * @param {number} [options]
 * @param {number} [options.N] 1 ≲ log2(N) ≲ 255
 * @param {number} [options.r] 1 ≲ r ≲ 255
 * @param {number} [options.p] 1 ≲ p ≲ 255
 */
const hash = async (password, data, options = SCRYPT_DEFAULT_OPTIONS) => {
  const {
    N = SCRYPT_DEFAULT_OPTIONS.N,
    r = SCRYPT_DEFAULT_OPTIONS.r,
    p = SCRYPT_DEFAULT_OPTIONS.p,
  } = options

  const iv = deriveIv({ N, r, p })
  const salt = await randomBytes(SCRYPT_DEFAULT_SALT_SIZE)

  return hashiv(password, iv, salt, data)
}

/**
 * Verifies a scrypt-based hash generated by `scrypt.hash()`.
 * @see hash
 * @param {(string|Buffer|TypedArray|DataView)} password
 * @param {(string|Buffer|TypedArray|DataView)} data
 * @param {Buffer} hash
 */
const verify = async (password, data, hash) => {
  const sizes = read(hash, [ 1, 1 ])
  const [ iv, salt ] = split(hash, sizes, 2)

  const scrypted = await hashiv(password, iv, salt, data)

  return timingSafeEqual(hash, scrypted)
}


module.exports = {
  hash,
  verify,
  subtle: {
    derive,
    deriveIv,
    deriveOptions,
    hashiv,
  },
  constants: {
    SCRYPT_DEFAULT_OPTIONS,
    SCRYPT_DEFAULT_IV_SIZE,
    SCRYPT_DEFAULT_SALT_SIZE,
  },
}
