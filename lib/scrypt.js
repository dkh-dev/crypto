'use strict'

const crypto = require('crypto')

const hmac = require('./hmac')
const randomBytes = require('./random-bytes')
const { callback } = require('./utils/promisify')
const bytes = require('./utils/bytes')


const SCRYPT_KEY_SIZE = 32

const SCRYPT_DEFAULT_OPTIONS = {
  N: 16384,
  r: 8,
  p: 1,
}

const SCRYPT_DEFAULT_IV_SIZE = {
  logN: 1,
  r: 1,
  p: 1,
}

const SCRYPT_DEFAULT_SALT_SIZE = 32


/**
 * log2(N), r, p must be of size `SCRYPT_DEFAULT_IV_SIZE`.
 *
 * Storing sizes of log2(N), r, p in the `iv` allows backwards-compatible
 *   verifications against a scrypt hash.
 */
const derivedIv = (
  options = SCRYPT_DEFAULT_OPTIONS,
  size = SCRYPT_DEFAULT_IV_SIZE,
) => {
  const { N, r, p } = options
  const parameters = [
    Math.log2(N),
    r,
    p,
  ]
  const sizes = [
    size.logN,
    size.r,
    size.p,
  ]

  const iv = bytes.from(sizes, parameters)

  const metadata = Uint8Array.from(sizes)

  return Buffer.concat([ metadata, iv ])
}


/**
 * Returns scrypt options derived from `iv`.
 */
const derivedOptions = iv => {
  // sizes
  const sizes = bytes.read(iv, Array(3).fill(1))
  const [ logN, r, p ] = bytes.read(iv, sizes, 3)

  return {
    r,
    p,
    N: 2 ** logN,
  }
}


/**
 * @private
 */
const scryptAsync = callback(crypto.scrypt)

/**
 * Note: You might want to use `scrypt.hash()` instead.
 */
const scrypt = (password, salt, keylen, options = SCRYPT_DEFAULT_OPTIONS) => {
  const {
    N = SCRYPT_DEFAULT_OPTIONS.N,
    r = SCRYPT_DEFAULT_OPTIONS.r,
    p = SCRYPT_DEFAULT_OPTIONS.p,
  } = options

  return scryptAsync(password, salt, keylen, { N, r, p, maxmem: 256 * N * r })
}

/**
 * Hash data using `scrypt`.
 *
 * Note: You might want to use `scrypt.hash()` instead.
 */
const scryptiv = async (password, iv, salt, data) => {
  const key = await scrypt(password, salt, SCRYPT_KEY_SIZE, derivedOptions(iv))
  const hash = await hmac.sha256(key, data)

  const metadata = Uint8Array.from([ iv.length, salt.length ])

  return Buffer.concat([
    metadata,
    iv,
    salt,
    hash,
  ])
}


/**
 * Hash data using `scrypt`.
 * @see verify
 * @param {(string|Buffer|TypedArray|DataView)} password
 * @param {(string|Buffer|TypedArray|DataView)} data
 * @param {number} [options]
 * @param {number} [options.N] 1 ≲ log2(N) ≲ 255
 * @param {number} [options.r] 1 ≲ r ≲ 255
 * @param {number} [options.p] 1 ≲ p ≲ 255
 */
const hash = async (password, data, options = SCRYPT_DEFAULT_OPTIONS) => {
  const {
    N = SCRYPT_DEFAULT_OPTIONS.N,
    r = SCRYPT_DEFAULT_OPTIONS.r,
    p = SCRYPT_DEFAULT_OPTIONS.p,
  } = options

  const iv = derivedIv({ N, r, p })
  const salt = await randomBytes(SCRYPT_DEFAULT_SALT_SIZE)

  return scryptiv(password, iv, salt, data)
}

/**
 * Recompute scrypt-based hash from hash or hash header.
 */
const rehash = (password, data, header) => {
  const sizes = bytes.read(header, Array(2).fill(1))
  const [ iv, salt ] = bytes.split(header, sizes, 2)

  return scryptiv(password, iv, salt, data)
}

/**
 * Verifies a scrypt-based hash generated by `scrypt.hash()`.
 * @see hash
 * @param {(string|Buffer|TypedArray|DataView)} password
 * @param {(string|Buffer|TypedArray|DataView)} data
 * @param {Buffer} hash
 */
const verify = async (password, data, hash) => {
  const scrypted = await rehash(password, data, hash)

  return crypto.timingSafeEqual(hash, scrypted)
}


module.exports = {
  SCRYPT_DEFAULT_OPTIONS,
  SCRYPT_DEFAULT_IV_SIZE,
  SCRYPT_DEFAULT_SALT_SIZE,
  hash,
  verify,
  rehash,
  scryptiv,
  derivedIv,
  derivedOptions,
  scrypt,
}
